{"ast":null,"code":"import { catchError, mapTo, of, throwError } from 'rxjs';\nimport { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./../autenticacao/token.service\";\nconst API = environment.API;\nconst NOT_MODIFIED = 304;\nexport let AnimaisService = /*#__PURE__*/(() => {\n  class AnimaisService {\n    constructor(httpClient, tokenService) {\n      this.httpClient = httpClient;\n      this.tokenService = tokenService;\n    }\n\n    listaDoUsuario(nomeUsuario) {\n      return this.httpClient.get(`${API}/${nomeUsuario}/photos`);\n    }\n\n    buscaPorID(id) {\n      return this.httpClient.get(`${API}/photos/${id}`);\n    }\n\n    excluiAnimal(id) {\n      return this.httpClient.delete(`${API}/photos/${id}`);\n    }\n\n    curtir(id) {\n      return this.httpClient.post(`${API}/photos/${id}/like`, {}, {\n        observe: 'response'\n      }).pipe( // fazer aqui um .pipe() porque eu quero manipular o fluxo da requisição,\n      // então eu vou usar o pipe para usar os operators. Caso a operação tenha sucesso, quero que ela retorne true.\n      mapTo(true), // Como eu quero que ela retorne true independentemente da mensagem que dê, simplesmente se for sucesso eu quero que retorne true,\n      // eu vou usar um operador chamado mapTo(), que ele vai sempre emitir o valor que eu colocar aqui, que no caso é (true).\n      // Se retornou 200 ou qualquer requisição de sucesso, 204, 202, etc., vai retornar true para o meu componente.\n      catchError(error => {\n        return error.status === NOT_MODIFIED ? of(false) : throwError(error);\n      })\n      /* Agora, se tiver algum erro, eu quero fazer a seguinte lógica, se o erro for not modify eu retorno como falso,\r\n             se for qualquer outro tipo de erro, eu vou fazer o throw do erro.\r\n           Para fazer isso nós vamos utilizar outro operador, então vou colocar aqui vírgula e o operador que nós vamos utilizar é o catchError(),\r\n               que só vai executar essa função se a requisição apresentar erro. E aqui eu vou passar uma função, que vai receber o (error),\r\n               e essa função nós vamos fazer o nosso tratamento.\r\n           Nosso tratamento vai ser o seguinte, eu vou retornar aqui, return, caso o status do error, então error.status === NOT_MODIFIED,\r\n               aquela constante que nós criamos lá em cima, eu quero que retorne, então interrogação, ? of, um observable que vai tornar (false).\r\n           Lembrando que nós sempre temos que retornar um observable, ou um observable true ou um observable que retorna false, mas nunca a variável só,\r\n             false ou true, tem que ser o observable. Então ele retorna um observable de (false). Caso contrário, então dois pontos, é uma opção ternária,\r\n               eu vou jogar o error, então throwError(error);.\r\n       */\n      );\n    }\n\n    upload(descricao, permiteComentario, arquivo) {\n      const formData = new FormData();\n      formData.append('description', descricao);\n      formData.append('allowComments', permiteComentario.toString());\n      formData.append('imageFile', arquivo); // faz o upload do form e faz o observe o evento de upload , e report o progresso do upload.\n\n      return this.httpClient.post(`${API}/photos/upload`, formData, {\n        observe: 'events',\n        reportProgress: true\n      });\n      /*\r\n        [05:24] Então eu não quero o response, eu quero os eventos, então cada passo da requisição eu quero receber no nosso observable,\r\n            eu quero que ele me envie. Então observe: ‘events’ e reportProgress: true,.\r\n              [05:54] E nesse método como ficou? Para o envio o segredo é envelopar o arquivo nesse formData e o\r\n            monitoramento nós fazemos utilizando esse objeto aqui embaixo.\r\n              [06:07] O que acontece? A cada passo da requisição, como estamos no observable, o Angular vai fazer um next nesse observable\r\n            mandando em que etapa está a requisição e nós conseguimos, lá no nosso componente, observar isso utilizando o subscribe,\r\n            e monitorar e mostrar isso para o nosso usuário.\r\n              [06:30] Como nós utilizamos o RxJS para o fluxo das requisições, nós vamos conseguir fazer esse acompanhamento de uma forma bem simples.\r\n            Vamos continuar essa tarefa e vamos criar o formulário de novo animal.\r\n              [06:46] Voltando na nossa linha de comando vamos utilizar o comando ng g animais/novo-animal. ng g,\r\n            generate novo animal, que ele vai criar o componente do novo animal.\r\n              [07:24] E uma vez criada, vamos configurar a rota desse componente. Já temos nosso serviço, vamos lá na nossa rota, “animais-routing.module.ts”, à esquerda.\r\n            E aqui, logo abaixo do path, nós vamos criar o path: ‘novo’ e o component: NovoAnimalComponent.\r\n              [07:59] Com isso nós temos o nosso serviço já configurado, o nosso componente\r\n            já inicializado e agora a rota configurada, e assim nós podemos continuar.\r\n      */\n    }\n\n  }\n\n  AnimaisService.ɵfac = function AnimaisService_Factory(t) {\n    return new (t || AnimaisService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.TokenService));\n  };\n\n  AnimaisService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AnimaisService,\n    factory: AnimaisService.ɵfac,\n    providedIn: 'root'\n  });\n  return AnimaisService;\n})();","map":null,"metadata":{},"sourceType":"module"}